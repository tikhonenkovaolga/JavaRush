package com.javarush.task.task30.task3013;

/* 
Набираем код Ӏ Java Multithreading: 10 уровень, 6 лекция
*/

public class Solution {
    public static void main(String[] args) {
        Solution solution = new Solution();
        int number = Integer.MAX_VALUE - 133;
        System.out.println(Integer.toString(number, 2));

        String result = Integer.toString(solution.resetLowerBits(number), 2);
        System.out.println(result);
    }

    public int resetLowerBits(int number) {
        number |= number >> 1;
        number |= number >> 2;
        number |= number >> 4;
        number |= number >> 8;
        number |= number >> 16;
        return number & ~(number >> 1);

        //напишите тут ваш код
    }
}


//
//    Итак. возьмём какое-нибудь число в двоичном коде в int (32 бита).
//        Вот такое, например (подчёркивания просто для удобства):
//        01000001_00111000_00001100_0001010
//
//        Делаем операцию number |= number >> 1.
//        Более развёрнутый вариант: number = number |= (number >> 1).
//        Что это всё значит?
//
//        А значит это:
//        1. Мы сдвигаем биты вправо на 1 ячейку
//        (появившаяся слева ячейка заполнится тем значением, которое там была раньше, т.е. в нашем случае 0).
//        00100000_10011100_00000110_0000101
//
//        2. Мы проводим побитовую операцию ИЛИ (знак |), которая сравнивает старый number c тем, который получился после сдвига ячеек.
//        Если кто не помнит, то этот оператор сравнивает ячейки в двух числах: если 1 или 0, он ставит 1, если 1 или 1, он ставит 1, если 0 или 0, он ставит ноль.
//        Выглядит это вот так:
//        01000001_00111000_00001100_00001010 - старое число
//        00100000_10011100_00000110_00000101 - новое число
//        --------------------------------------------------------
//        01100001_10111100_00001110_00001111 - результат
//
//        Повторяем эту операцию, сдвигая ячейки, соответственно, на 2, 4, 8 и 16 бит (сейчас увидите зачем).
//        00011000_01101111_00000011_1000011 - сдвиг на 2 вправо
//        01111001_11111111_00001111_10001111 - результат сравнения с предыдущим результатом
//        00000111_10011111_11110000_11111000 - сдвиг на 4 вправо
//        01111111_11111111_11111111_11111111 - результат сравнения с предыдущим результатом
//
//        В принципе, здесь хватило сдвига на 4. Но ниже в комментариях рекомендовали также делать сдвиг на 8 и на 16
//        (мне сложно объяснить, зачем, видимо, для некоторых комбинаций сдвигом на 2 и на 4 н
//Теперь мы с получившимся числом делаем операцию number &= ~number >> 1. Что теперь это значит?
//        1. Оператор ~ (побитовый "не") как бы инвертирует число. Т.е. мы получаем такое:
//        10000000_00000000_00000000_00000000
//        2. Делаем сдвиг вправо на 1 бит. Получаем:
//        01000000_00000000_00000000_00000000
//        3. Делаем побитовое сравнение "И" (&), которое сравнивает два числа и в результат выводит только те единички, которые совпадают у обоих. Получаем:
     //   01000000_00000000_00000000_00000000 - это и будет ответ.